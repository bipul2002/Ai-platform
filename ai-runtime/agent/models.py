from typing import List, Optional, Union, Literal
from pydantic import BaseModel, Field

class JoinCondition(BaseModel):
    left_column: str = Field(..., description="Column from the left table, e.g., 't1.id'")
    operator: str = Field("=", description="Operator for the join condition, usually '='")
    right_column: str = Field(..., description="Column from the right table, e.g., 't2.user_id'")

class JoinStructure(BaseModel):
    type: Literal["INNER", "LEFT", "RIGHT", "FULL"] = Field("INNER", description="Type of join")
    table: str = Field(..., description="Name of the table to join")
    alias: str = Field(..., description="Alias for the joined table")
    on: JoinCondition = Field(..., description="Condition for the join")

class FilterCondition(BaseModel):
    column: str = Field(..., description="Column to filter on")
    operator: str = Field(..., description="Operator: =, !=, >, <, >=, <=, LIKE, ILIKE, IN, BETWEEN")
    value: Union[str, int, float, List[str], List[int], List[float]] = Field(..., description="Value(s) for the filter")

class TableReference(BaseModel):
    name: str = Field(..., description="Name of the database table")
    alias: str = Field(..., description="Alias for the table used in the query")

class ColumnReference(BaseModel):
    column: str = Field(..., description="Full column reference, e.g., 't.id'")
    alias: Optional[str] = Field(None, description="Optional alias for the column output")
    aggregate: Optional[str] = Field(None, description="Optional aggregation function like COUNT, SUM, AVG")

class OrderBy(BaseModel):
    column: str = Field(..., description="Column to order by")
    direction: Literal["ASC", "DESC"] = Field("ASC", description="Sort direction")

class QueryStructure(BaseModel):
    """Simplified canonical representation of a SQL query response."""
    generated_sql: str = Field(..., description="The final, dialect-specific SQL query generated by the LLM. You MUST populate this.")
    sql_explanation: str = Field(..., description="A concise 3-5 word DATA TITLE describing the result (e.g. 'Procuring Entities by Contract Count'). Do NOT use verbs like 'Fetch', 'Select', 'Get'. Describe the NOUNS.")
    correction_note: Optional[str] = Field(None, description="Note if the query was auto-corrected from direct SQL or if restrictions were applied")

    class Config:
        extra = "allow"

class SQLCorrection(BaseModel):
    """Model for dedicated SQL correction."""
    generated_sql: str = Field(..., description="The complete corrected SQL query")
    correction_note: Optional[str] = Field(None, description="Explanation of what was fixed")

class SortCondition(BaseModel):
    column: str = Field(..., description="Column name or alias to sort by")
    order: Literal["ascending", "descending"] = Field("ascending", description="Sort order")

class RefinementChanges(BaseModel):
    add_filters: List[FilterCondition] = Field(default_factory=list, description="New filters to add")
    remove_filters: List[str] = Field(default_factory=list, description="Column names of filters to remove")
    change_sort: Optional[SortCondition] = Field(None, description="New sorting condition")
    change_limit: Optional[int] = Field(None, description="New limit value")
    add_columns: List[Union[str, ColumnReference]] = Field(default_factory=list, description="New columns to add")
    remove_columns: List[str] = Field(default_factory=list, description="Column names or aliases to remove")

class TimeframeResolution(BaseModel):
    specified: bool = Field(False, description="Whether a specific timeframe was mentioned")
    raw_value: Optional[str] = Field(None, description="The raw timeframe string from the user")
    resolved_start: Optional[str] = Field(None, description="ISO format start date/time")
    resolved_end: Optional[str] = Field(None, description="ISO format end date/time")

class IntentStructure(BaseModel):
    """Model for unified intent analysis and orchestration."""
    primary_intent: Literal["database_query", "data_guide", "greeting", "query_explanation", "correction", "out_of_scope"] = Field(..., description="The main intent category")
    
    # Security Gate
    is_direct_sql: bool = Field(False, description="True if the user provided a raw SQL query")
    is_readonly_sql: bool = Field(True, description="True if the SQL query is a SELECT statement")
    rejected: bool = Field(False, description="True if the security gate blocks this request")
    rejection_reason: Optional[str] = Field(None, description="Description of why the query was rejected")
    detected_operation: Optional[str] = Field(None, description="Mutating operation detected, e.g., DELETE, UPDATE")
    
    # Core Intent
    intent_summary: str = Field("", description="Concise summary of user's core intent")
    extracted_timeframe: TimeframeResolution = Field(default_factory=TimeframeResolution, description="Resolved timeframe constraints")
    
    # Ambiguity
    is_ambiguous: bool = Field(False, description="True if the request is semantically unclear")
    ambiguity_reason: Optional[str] = Field(None, description="Explanation of ambiguity")
    clarifying_questions: List[str] = Field(default_factory=list, description="Questions to ask the user")
    assumptions_made: List[str] = Field(default_factory=list, description="Any internal resolutions/assumptions made")
    
    # Refinement
    is_refinement: bool = Field(False, description="True if this is a refinement of the previous query")
    refinement_type: Optional[Literal["filter", "sort", "limit", "columns", "aggregation"]] = Field(None, description="Type of refinement")
    refinement_complexity: Optional[Literal["simple", "complex"]] = Field(None, description="Complexity of refinement")
    base_query_to_modify: Optional[str] = Field(None, description="The previous SQL that serves as the base for this refinement")
    changes: Optional[RefinementChanges] = Field(None, description="Specific modifications for refinement")
    
    # Schema Needs
    needs_schema_search: bool = Field(False, description="Whether full vector search for new tables is needed")
    new_entities: List[str] = Field(default_factory=list, description="Table names NOT in previous context")
    required_tables: List[str] = Field(default_factory=list, description="All tables from schema summary required for this query")
    
    # Routing
    route_to: Literal["query_builder", "none"] = Field("query_builder", description="Where to send this request next")
    direct_response: Optional[str] = Field(None, description="Final response text if route_to is 'none'")
    confidence: float = Field(0.0, description="LLM confidence score for this analysis")
    
    logic_reasoning: Optional[str] = Field(None, description="Internal reasoning for these decisions")
